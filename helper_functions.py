import tifffile as tf
import numpy as np
import matplotlib.pyplot as plt
import os
import sys
from scipy import spatial
import pandas as pd
import seaborn as sns
import PIL
from math import sqrt
import matplotlib.patheffects as PathEffects
import random
from tqdm import tqdm
from scipy.optimize import minimize
from PIL import Image
from pims_nd2 import ND2_Reader as nd2_opener
from os import listdir
from os.path import isfile, join
import warnings


''' Functions for retrieving tile coordinates'''

#this function retrieves center point coordinates for every tile image in a directory and generates a dataframe where every row is a tile, with i and j coordinates 
def RetrieveCoordinates_in_df(path_to_directory, well_ID):
    tile_coords_dict = {}
    for filename in os.listdir(path_to_directory):
        if filename.endswith(".tif") and ("Well" + str(well_ID)) in filename:
            x,y = GetTileCoordinates_from_raw_tif(input_tif = path_to_directory + filename, rotate_180=True)
            tile_name = filename.split("_")[2].lstrip("0")
            if tile_name == '':
                tile_name = 0
            tile_name = int(tile_name)
            tile_coords_dict[tile_name] = float(x),float(y)
            continue
        else:
            continue
        
    df_coords = pd.DataFrame.from_dict(tile_coords_dict, orient='index')
    df_coords = df_coords.sort_index()
    df_coords = df_coords.rename(columns={0: "i_tilecenter", 1: "j_tilecenter"}, errors="raise")
    
    return(df_coords)

def GetTileCoordinates_from_raw_tif(input_tif, rotate_180 = True):
    with tf.TiffFile(input_tif) as tif:
        for page in tif.pages:
            for tag in page.tags:
                tag_name, tag_value = tag.name, tag.value
                if tag_name in ['ImageDescription']:
                    im_description = tag_value
                    values = im_description.split(" ")
                
                    x_value = [value for value in values if value.startswith('PositionX')][0]
                    x_coordinate = x_value.split("=")[1].strip('"')
                
                    y_value = [value for value in values if value.startswith('PositionY')][0]
                    y_coordinate = y_value.split("=")[1].strip('"')
                    
                    if rotate_180 == True:
                        x_coordinate = float(x_coordinate)*-1
                        y_coordinate = float(y_coordinate)*-1
                
                    x,y = str(x_coordinate), str(y_coordinate)
                
                    return x,y

def GetCoordinates_from_raw_tif(input_tif):
    with tf.TiffFile(input_tif) as tif:
        for page in tif.pages:
            for tag in page.tags:
                tag_name, tag_value = tag.name, tag.value
                if tag_name in ['ImageDescription']:
                    im_description = tag_value
                    values = im_description.split(" ")
                
                    x_value = [value for value in values if value.startswith('PositionX')][0]
                    x_coordinate = x_value.split("=")[1].strip('"')
                
                    y_value = [value for value in values if value.startswith('PositionY')][0]
                    y_coordinate = y_value.split("=")[1].strip('"')
                
                    x,y = x_coordinate, y_coordinate
                
                    return x,y

''' Functions for nominating fiducial tiles '''

def ApproximateRadiusAndCentroid(df):

    #first, approximate the radius based on tile coordinates:
    top_y = df['j_tilecenter'].max()
    bottom_y = df['j_tilecenter'].min()
    
    approx_diam = abs(top_y - bottom_y)
    radius = approx_diam/2
    
    #next, calculate x,y coordinate of centroid:
    centroid = df.to_numpy().mean(axis=0)
    
    return(radius, centroid)

def GetFiducialTilesFromCentroid(radius, centroid, radius_fraction):
    x = centroid[0]
    y = centroid[1]
    
    r = radius*radius_fraction
    
    top_xy = x, y+r
    bottom_xy = x, y-r
    left_xy = x-r, y
    right_xy = x+r, y
    
    coords = (top_xy, bottom_xy, left_xy, right_xy)
    
    df = pd.DataFrame(coords, columns=['i_tilecenter', 'j_tilecenter'])
    
    return(df)

def GetFiducialTilesFromCentroid_atAngle(radius, centroid, radius_fraction):
    #this is to identify tiles to find additional fiducial tiles
    #this time at 45 degree angle to those generated by GetFiducialTilesFromCentroid
    
    x = centroid[0]
    y = centroid[1]
    
    r = radius*radius_fraction
    #d is distance to apply to x and y from centroid to get tile coordinates at 45deg angle
    d = r/sqrt(2)
    
    upper_left_xy = x-d, y+d
    upper_right_xy = x+d, y+d
    lower_right_xy = x+d, y-d
    lower_left_xy = x-d, y-d
    
    coords = (upper_left_xy, upper_right_xy, lower_right_xy, lower_left_xy)
    
    df = pd.DataFrame(coords, columns=['i_tilecenter', 'j_tilecenter'])
    
    return(df)
    
def GetNearestNeighborForEachPoint(query_points_df, potential_neighbors_df, label):
    
    #convert to numpy arrays so can find neighbor
    query_points = np.asarray(query_points_df.iloc[:, -2:])
    potential_neighbors = np.asarray(potential_neighbors_df.iloc[:, -2:])
    
    found_tiles = []
    for point in query_points:
        nearest_neighbor_point_index = spatial.KDTree(potential_neighbors).query(point)[1]
        found_tiles.append(nearest_neighbor_point_index)

    return_df = potential_neighbors_df.loc[found_tiles]

    #retrieve tile number from index
    df_reset = return_df.reset_index().rename(columns={'index': 'tile_'+label, 'i_tilecenter':'i_tilecenter_'+label, 'j_tilecenter':'j_tilecenter_'+label})
    
    return(df_reset)


def GenerateFiducials_df(lomag_df, himag_df, well_radius, well_centroid, radius_frac=0.9):
    
    #get points in a cross with tile centroid as center point
    fidu_df_cross = GetFiducialTilesFromCentroid(radius=well_radius, centroid=well_centroid, radius_fraction=radius_frac)
    fidu_df_angle = GetFiducialTilesFromCentroid_atAngle(radius=well_radius, centroid=well_centroid, radius_fraction=radius_frac)

    fidu_tiles_coordinates = pd.concat([fidu_df_cross, fidu_df_angle], axis=0)

    fidu_tiles_himag = GetNearestNeighborForEachPoint(fidu_tiles_coordinates, himag_df, "himag")
    fidu_tiles_lomag = GetNearestNeighborForEachPoint(fidu_tiles_himag, lomag_df, "lomag")

    fiducial_tiles = pd.concat([fidu_tiles_himag, fidu_tiles_lomag], axis=1)

    return(fiducial_tiles)

''' Functions for printing images of fiducial tiles to search for cells '''

def Load_TIF(full_path, verbose=False):
    try:
        _data = np.array(PIL.Image.open(full_path), dtype=np.float64)
        #if _data.shape[0] == np.array(0, dtype=tuple):
        if _data.size ==0:
            print('Image is empty')
            sys.exit()

        if verbose:
            (f"Image loaded: {full_path} with shape {_data.shape}")
    
        return(_data)

    except FileNotFoundError:
        print(f"Image not found at {full_path}")
        sys.exit()


def PrintImagesWithAllNucCentroids(tile_lomag, tile_himag, lomag_image_dir, himag_image_dir,
                                   cells_lomag_df, cells_himag_df,
                                   well, suppress_labels=False, sample_lomag=0.5, _vmax=2500):
    
    #subset cells in dataframes to only include those in the pre-selected fiducial tiles
    cells_in_tile_lomag = cells_lomag_df.loc[(cells_lomag_df['tile'] == tile_lomag) & (cells_lomag_df['well'] == well)].reset_index()
    cells_in_tile_himag = cells_himag_df.loc[(cells_himag_df['tile'] == tile_himag) & (cells_himag_df['well'] == well)].reset_index()
    
    label_alpha = 1
    if suppress_labels == True:
        label_alpha = 0
    
    filepath_image_lomag = lomag_image_dir + "10X_" + str(well) + "_Tile-" + str(tile_lomag) + ".annotate_segment.tif"
    filepath_image_himag = himag_image_dir + "40X_" + str(well) + "_Tile-" + str(tile_himag) + ".annotate_segment.tif"
    
    img_lomag = Load_TIF(filepath_image_lomag)
    img_himag = Load_TIF(filepath_image_himag)
    
    plt.rcParams["figure.figsize"] = (20,10)
    plt.subplot(1,2,1)
    
    #if necessary, sub-samples 10X cells (can be helpful if tile has high density of cells)
    cells_in_tile_lomag_sample = cells_in_tile_lomag.sample(frac=sample_lomag).reset_index()
    
    #lomag, plot image then put centroids & labels on
    plt.imshow(img_lomag, cmap='gray', vmin=0, vmax=0.7*_vmax)
    plt.scatter(x=cells_in_tile_lomag_sample['j_nucleus'], y=cells_in_tile_lomag_sample['i_nucleus'],
                c='magenta', s=0.2)
    
    for i in range(len(cells_in_tile_lomag_sample['j_nucleus'])):
        x = cells_in_tile_lomag_sample['j_nucleus'][i]
        y = cells_in_tile_lomag_sample['i_nucleus'][i]
        plt.text(x * (1 + 0.01), y * (1 + 0.01) , cells_in_tile_lomag_sample['cell'][i], 
                 fontsize=7, c='white', alpha=label_alpha)
        
    plt.subplot(1,2,2)
    plt.imshow(img_himag, cmap='gray', vmin=0, vmax=_vmax*2)
    plt.scatter(x=cells_in_tile_himag['j_nucleus'], y=cells_in_tile_himag['i_nucleus'],
                c='black', s=1)
    
    #label centroids with cell IDs - himag
    for i in range(len(cells_in_tile_himag['j_nucleus'])):
        x = cells_in_tile_himag['j_nucleus'][i]
        y = cells_in_tile_himag['i_nucleus'][i]
        txt = plt.text(x * (1 + 0.01), y * (1 + 0.01) , cells_in_tile_himag['cell'][i], 
                 fontsize=7, c='yellow', alpha=label_alpha)
        txt.set_path_effects([PathEffects.withStroke(linewidth=2, foreground='black')])
    
    plt.show()
    return()


''' Functions to calculate tile orientation '''

def GenerateTileGrid(path_name, well=1):
    
    #first, generate the (potentially inaccurate) array representing a grid of tiles within the well
    wellname = 'Well' + str(well)

    tifs = [f for f in listdir(path_name) if isfile(os.path.join(path_name, f)) and join(path_name, f).endswith('.tif')
                and wellname in join(path_name, f)]

    assert len(tifs)!=0, 'No tif files found'

    coord_df = pd.DataFrame(columns=['filename','tile_num','x','y','mpp'])

    #plot tiles from this array to identify appropriate transformation
    for t, filename in enumerate(tqdm(tifs)):
        
        img_name = os.path.join(path_name,filename)
        
        #extracting metadata from tifs
        with tf.TiffFile(img_name) as tif:
            for page in tif.pages:
                for tag in page.tags:
                    tag_name, tag_value = tag.name, tag.value
                    if tag_name in ['ImageDescription']:
                        im_description = tag_value
                        values = im_description.split(" ")
                
                        x_value = [value for value in values if value.startswith('PositionX')][0]
                        x_coordinate = float(x_value.split("=")[1].strip('"'))
                
                        y_value = [value for value in values if value.startswith('PositionY')][0]
                        y_coordinate = float(y_value.split("=")[1].strip('"'))
                            
                        mpp_x_dim_entry = [value for value in values if value.startswith('PhysicalSizeX')][0]
                        mpp = float(mpp_x_dim_entry.split("=")[1].strip('"')) #this is microns per pixel
                        #our camera is square so there is one micron per pixel value

        tile_num = int(filename.split("_Channel")[0].split("_")[-1])

        #add the entry corresponding to this tile as the next line in a growing dataframe
        coord_df.loc[len(coord_df)] = [img_name, tile_num, x_coordinate, y_coordinate, mpp]
    
    coord_df = coord_df.sort_values(by='tile_num')

    #loading an image to get h,w
    img = Load_TIF(os.path.join(path_name, tifs[0]))
    h, w = np.array(img).shape

    # Normalized coordinates for grid creation (using the previously calculated X and Y)
    coord_df['X'] = (coord_df['x'] - coord_df['x'].min()) / (coord_df['mpp'] * w)
    coord_df['Y'] = (coord_df['y'] - coord_df['y'].min()) / (coord_df['mpp'] * h)

    X = np.array(coord_df['X'])
    Y = np.array(coord_df['Y'])

    #creating a 2D grid of tiles -original grid
    test_grid = -1 * np.ones([int(Y.max()+1), int(X.max()+1)], dtype=int) #background set at -1: this is value of non-tile on grid)
    for i in range(len(X)):
        test_grid[int(round(Y[i])), int(round(X[i]))] = i

    return(test_grid, coord_df)


def TestTileGrid(tiles_dict, image_dir, coords_df, zoom=False, zoom_factor=0.6):

    # Function to load and apply transformations
    def apply_transformation(image, transformation):
        if transformation == 'None':
            return image
        elif transformation == 'transpose':
            return np.transpose(image)
        elif transformation == 'fliplr':
            return np.fliplr(image)
        elif transformation == 'flipud':
            return np.flipud(image)
        elif transformation == 'flip':
            return np.flip(image)
        elif transformation == 'transpose -> flipud':
            return np.flipud(np.transpose(image))
        elif transformation == 'transpose -> fliplr':
            return np.fliplr(np.transpose(image))
        elif transformation == 'transpose -> flip':
            return np.flip(np.transpose(image))
 
    # Load the four images (example file paths, replace with actual file paths)
    image_dict = {}
    for spot in tiles_dict.keys():
        img_name = f"img_{spot}"
        
        image_dict[img_name] = np.array(Image.open(coords_df.loc[coords_df['tile_num'] == tiles_dict[spot], 'filename'].iloc[0]))

    # List of transformations to examine
    transformations = ['None', 'transpose', 'fliplr', 'flipud', 'flip', 
                       'transpose -> flipud', 'transpose -> fliplr', 'transpose -> flip']
    
    # Apply transformations and plot
    for i, transformation in enumerate(transformations):
        transformed_images = []
    
        # Apply the transformation to each image and store them in a list
        for position in image_dict.keys():
            transformed_img = apply_transformation(image_dict[position], transformation)
            transformed_images.append(transformed_img)
    
        # Stack the images into one large image (2x2 grid)
        top_row = np.hstack([transformed_images[0], transformed_images[1]])  # Top-left and top-right
        bottom_row = np.hstack([transformed_images[2], transformed_images[3]])  # Bottom-left and bottom-right
        combined_img = np.vstack([top_row, bottom_row])  # Stack top and bottom rows vertically

        if zoom:
            image = combined_img
            
            # Get the image dimensions (height, width)
            height, width = image.shape[:2]
            
            # Calculate the center coordinates
            center_y, center_x = height // 2, width // 2
            
            # Define the size of the zoomed-in region (based on the zoom factor)
            crop_height = int(height * (1 - zoom_factor))
            crop_width = int(width * (1 - zoom_factor))
            
            # Calculate the cropping boundaries
            top = center_y - crop_height // 2
            bottom = center_y + crop_height // 2
            left = center_x - crop_width // 2
            right = center_x + crop_width // 2
            
            # Ensure the boundaries do not go out of image dimensions
            top = max(top, 0)
            bottom = min(bottom, height)
            left = max(left, 0)
            right = min(right, width)
            
            # Crop the image
            combined_img = image[top:bottom, left:right]

        plt.imshow(combined_img)
        plt.title(f'{transformation}')
        plt.axis('off')
    
        plt.tight_layout()
        plt.show()
    
    #return(image_dict)

def SetTileConfiguration(transformation, grid):
    
    transform_list = ['original','transpose','fliplr','flipud','flip','transpose_fliplr','transpose_flipud','transpose_flip']

    assert transformation in transform_list, 'chosen transform is not an option. Options are: original, transpose, fliplr, flipud, dlip, transpose_fliplr, transpose_flipud, or transpose_flip.'
    
    if transformation == 'original':
        return grid
    elif transformation == 'transpose':
        return np.transpose(grid)
    elif transformation == 'fliplr':
        return np.fliplr(grid)
    elif transformation == 'flipud':
        return np.flipud(grid)
    elif transformation == 'flip':
        return np.flip(grid)
    elif transformation == 'transpose -> flipud':
        return np.flipud(np.transpose(grid))
    elif transformation == 'transpose -> fliplr':
        return np.fliplr(np.transpose(grid))
    elif transformation == 'transpose -> flip':
        return np.flip(np.transpose(grid))

''' Functions to calculate relationship between low mag and high mag locations '''

def GetTilewiseLocations(df, himag_df, lomag_df, well):

    #add a column corresponding to within tile cell location based on matching columns

    #generate for himag info
    himag_df=himag_df[himag_df['well']==well]
    merged_df = pd.merge(df, himag_df[['cell', 'tile', 'well', 'i_nucleus','j_nucleus']], left_on = ['cell_himag', 'tile_himag'], right_on=['cell','tile'], how='inner')
    
    #need form tile, i, j
    himag_coords_df = merged_df[['tile_himag','i_nucleus','j_nucleus']].astype(int) #pixel loci must be integers (i.e. cannot have half a pixel)

    #repeat for lomag
    lomag_df=lomag_df[lomag_df['well']==well]
    merged_df = pd.merge(df, lomag_df[['cell', 'tile', 'well', 'i_nucleus','j_nucleus']], left_on = ['cell_lomag', 'tile_lomag'], right_on=['cell','tile'], how='inner')
    lomag_coords_df = merged_df[['tile_lomag','i_nucleus','j_nucleus']].astype(int)

    return(np.array(himag_coords_df), np.array(lomag_coords_df))

def Local_to_Global(_P , _M, _Size):
    #written by Tomer Lapidot
    _P = np.array(_P, dtype=int)

    _P_out = np.empty([len(_P), 2], dtype=int)

    for p in range(len(_P)):

        M_i, M_j = np.where(_M == _P[p, 0])
        
        M_i = np.squeeze(M_i)
        M_j = np.squeeze(M_j)

        _P_out[p, 0] = int(_Size[0]*M_i + _P[p, 1])
        _P_out[p, 1] = int(_Size[1]*M_j + _P[p, 2])

    return _P_out

def Fit_By_Points(_P_10X, _P_40X, verbose=False):
    #written by Tomer Lapidot
    
    _P_10X = np.array(_P_10X)
    _P_40X = np.array(_P_40X)

    x0 = (0, 0, 0, 0, 0)

    res = minimize(fun_min, x0, args=(_P_10X, _P_40X), method='SLSQP')

    _P = model_TRS(_P_10X, res.x)

    if verbose:
        print(res)
        print('Pixel Errors (X,Y)')
        for p in range(len(_P)):
            print('Point ', p, [round(_P_40X[p, 0] - _P[p, 0]), round(_P_40X[p, 1] - _P[p, 1])])

    return res.x

def model_TRS(_P_10X_, dof, angle='degree'):
    #written by Tomer Lapidot
    
    _P_10X_ = np.array(_P_10X_)

    if angle == 'degree':
        a = np.pi * dof[2] / 180
    else:
        a = dof[2]

    X = dof[3] * (np.cos(a) * _P_10X_[:, 0] - np.sin(a) * _P_10X_[:, 1] + dof[0])
    Y = dof[4] * (np.sin(a) * _P_10X_[:, 0] + np.cos(a) * _P_10X_[:, 1] + dof[1])

    _P_out = np.concatenate((X.reshape(len(X),1), Y.reshape(len(Y),1)), axis=1)

    return _P_out

def fun_min(x, _P_10X_, _P_40X_, _angle='degree'):
    #written by Tomer Lapidot
    
    _P_10X_ = np.array(_P_10X_)
    _P_40X_ = np.array(_P_40X_)

    assert _P_10X_.shape == _P_40X_.shape, 'Number of points must be the same in both magnifications'

    _P = model_TRS(_P_10X_, x, angle=_angle)

    obj = np.sum((_P[:, 0] - _P_40X_[:, 0]) ** 2 + (_P[:, 1] - _P_40X_[:, 1]) ** 2)

    return np.sum(obj)

def Global_to_Local(_P, _M, _Size, clamped=True):
    #modified from function written by Tomer Lapidot

    _P = np.array(_P, dtype=int)

    _P_out = np.empty([len(_P), 3], dtype=int)

    for p in range(len(_P)):
        
        M_i = int(_P[p, 0] / _Size[0])
        M_j = int(_P[p, 1] / _Size[1])

        if clamped:
            M_i = min(M_i, _M.shape[0] - 1)
            M_j = min(M_j, _M.shape[1] - 1)

        _P_out[p, 0] = int(_M[M_i, M_j])

        _P_out[p, 1] = int(_P[p, 0] - M_i * _Size[0])
        _P_out[p, 2] = int(_P[p, 1] - M_j * _Size[1])

    return _P_out

''' Functions to verify calculated relationship between low mag and high mag locations '''
def Plot_Point_Mapping_tif(_p_10X, _p_40X, _Tile_List_10X, _Tile_List_40X, _path_10X, _path_40X, _channel=0, _vmax=2000):
    #modified from function written by Tomer Lapidot
    
    def get_last3d(data):
        if data.ndim <= 3:
            return data
        slc = [0] * (data.ndim - 3)
        slc += [slice(None), slice(None)]
        return data[slc]

    _p_10X = np.array(_p_10X)
    _p_40X = np.array(_p_40X)

    for p in tqdm(range(len(_p_10X))):

        _q_10X = _p_10X[p, :]
        _q_40X = _p_40X[p, :]

        tile_name_10X = _Tile_List_10X['filename'].iloc[_q_10X[0]]
        tile_name_40X = _Tile_List_40X['filename'].iloc[_q_40X[0]]
        
        img_10X = get_last3d(np.array(Image.open(tile_name_10X)))
        img_40X = get_last3d(np.array(Image.open(tile_name_40X)))

        plt.rcParams["figure.figsize"] = (12,6)
        plt.subplot(1, 2, 1)
        plt.imshow(img_10X, cmap='gray', vmin=0, vmax=0.7*_vmax)
        plt.scatter(_q_10X[2], _q_10X[1], s=2, c='red')

        plt.subplot(1, 2, 2)
        plt.imshow(img_40X, cmap='gray', vmin=0, vmax=_vmax)
        plt.scatter(_q_40X[2], _q_40X[1], s=2, c='red')

        plt.show()


